/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter, ElementRef } from '@angular/core';
import * as chartJs from 'chart.js';
import { getColors } from './get-colors';
/**
 * @record
 */
export function PluginServiceGlobalRegistration() { }
if (false) {
    /** @type {?|undefined} */
    PluginServiceGlobalRegistration.prototype.id;
}
/**
 * @record
 */
export function PluginServiceRegistrationOptions() { }
if (false) {
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeInit = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterInit = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeLayout = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterLayout = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetsUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetsUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetUpdate = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeRender = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterRender = function (chartInstance, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetsDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetsDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeDatasetDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} easing
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterDatasetDraw = function (chartInstance, easing, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} tooltipData
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeTooltipDraw = function (chartInstance, tooltipData, options) { };
    /**
     * @param {?} chartInstance
     * @param {?=} tooltipData
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterTooltipDraw = function (chartInstance, tooltipData, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} event
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.beforeEvent = function (chartInstance, event, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} event
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterEvent = function (chartInstance, event, options) { };
    /**
     * @param {?} chartInstance
     * @param {?} newChartSize
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.resize = function (chartInstance, newChartSize, options) { };
    /**
     * @param {?} chartInstance
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.destroy = function (chartInstance) { };
    /**
     * @deprecated since version 2.5.0. Use `afterLayout` instead.
     * @param {?} chartInstance
     * @param {?=} options
     * @return {?}
     */
    PluginServiceRegistrationOptions.prototype.afterScaleUpdate = function (chartInstance, options) { };
}
export class BaseChartDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.initFlag = false;
    }
    /**
     * Register a plugin.
     * @param {?} plugin
     * @return {?}
     */
    static registerPlugin(plugin) {
        chartJs.Chart.plugins.register(plugin);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ctx = this.element.nativeElement.getContext('2d');
        this.initFlag = true;
        if (this.data || this.datasets) {
            this.refresh();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.initFlag) {
            /** @type {?} */
            let updateRequired = false;
            // Check if the changes are in the data or datasets or labels or legend
            if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                if (changes.data) {
                    this.updateChartData(changes.data.currentValue);
                }
                else {
                    this.updateChartData(changes.datasets.currentValue);
                }
                updateRequired = true;
            }
            if (changes.hasOwnProperty('labels')) {
                this.chart.data.labels = changes.labels.currentValue;
                updateRequired = true;
            }
            if (changes.hasOwnProperty('legend')) {
                this.chart.config.options.legend.display = changes.legend.currentValue;
                this.chart.generateLegend();
                updateRequired = true;
            }
            if (updateRequired) {
                // ... if so, update chart
                this.chart.update();
            }
            else {
                // otherwise rebuild the chart
                this.refresh();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
    }
    /**
     * @param {?=} duration
     * @param {?=} lazy
     * @return {?}
     */
    update(duration, lazy) {
        return this.chart.update(duration, lazy);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    getChartBuilder(ctx /*, data:any[], options:any*/) {
        /** @type {?} */
        const datasets = this.getDatasets();
        /** @type {?} */
        const options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hook for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = (/**
             * @param {?} event
             * @param {?} active
             * @return {?}
             */
            (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            });
        }
        if (!options.onClick) {
            options.onClick = (/**
             * @param {?=} event
             * @param {?=} active
             * @return {?}
             */
            (event, active) => {
                this.chartClick.emit({ event, active });
            });
        }
        /** @type {?} */
        const chartConfig = {
            type: this.chartType,
            data: {
                labels: this.labels,
                datasets
            },
            options
        };
        return new chartJs.Chart(ctx, chartConfig);
    }
    /**
     * @private
     * @param {?} v
     * @return {?}
     */
    isChartDataSetsArray(v) {
        /** @type {?} */
        const elm = v[0];
        return (typeof (elm) === 'object') && 'data' in elm;
    }
    /**
     * @private
     * @param {?} newDataValues
     * @return {?}
     */
    updateChartData(newDataValues) {
        if (this.isChartDataSetsArray(newDataValues)) {
            if (newDataValues.length === this.chart.data.datasets.length) {
                this.chart.data.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                (dataset, i) => {
                    dataset.data = newDataValues[i].data;
                    if (newDataValues[i].label) {
                        dataset.label = newDataValues[i].label;
                    }
                }));
            }
            else {
                this.chart.data.datasets = [...newDataValues];
            }
        }
        else if (!this.isSingleDataSet(newDataValues)) {
            if (newDataValues.length === this.chart.data.datasets.length) {
                this.chart.data.datasets.forEach((/**
                 * @param {?} dataset
                 * @param {?} i
                 * @return {?}
                 */
                (dataset, i) => {
                    dataset.data = newDataValues[i];
                }));
            }
            else {
                this.chart.data.datasets = newDataValues.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.labels[index] || `Label ${index}` };
                }));
            }
        }
        else {
            this.chart.data.datasets[0].data = newDataValues;
        }
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    isSingleDataSet(data) {
        return !Array.isArray(data[0]);
    }
    /**
     * @private
     * @return {?}
     */
    getDatasets() {
        /** @type {?} */
        let datasets = void 0;
        // in case if datasets is not provided, but data is present
        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
            if (!this.isSingleDataSet(this.data)) {
                datasets = this.data.map((/**
                 * @param {?} data
                 * @param {?} index
                 * @return {?}
                 */
                (data, index) => {
                    return { data, label: this.labels[index] || `Label ${index}` };
                }));
            }
            else {
                datasets = [{ data: this.data, label: `Label 0` }];
            }
        }
        if (this.datasets && this.datasets.length ||
            (datasets && datasets.length)) {
            datasets = (this.datasets || datasets)
                .map((/**
             * @param {?} elm
             * @param {?} index
             * @return {?}
             */
            (elm, index) => {
                /** @type {?} */
                const newElm = Object.assign({}, elm);
                if (this.colors && this.colors.length) {
                    Object.assign(newElm, this.colors[index]);
                }
                else {
                    Object.assign(newElm, getColors(this.chartType, index, newElm.data.length));
                }
                return newElm;
            }));
        }
        if (!datasets) {
            throw new Error(`ng-charts configuration error,
      data or datasets field are required to render char ${this.chartType}`);
        }
        return datasets;
    }
    /**
     * @private
     * @return {?}
     */
    refresh() {
        // if (this.options && this.options.responsive) {
        //   setTimeout(() => this.refresh(), 50);
        // }
        // todo: remove this line, it is producing flickering
        this.ngOnDestroy();
        this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
    }
}
BaseChartDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'canvas[baseChart]',
                exportAs: 'base-chart'
            },] }
];
/** @nocollapse */
BaseChartDirective.ctorParameters = () => [
    { type: ElementRef }
];
BaseChartDirective.propDecorators = {
    data: [{ type: Input }],
    datasets: [{ type: Input }],
    labels: [{ type: Input }],
    options: [{ type: Input }],
    chartType: [{ type: Input }],
    colors: [{ type: Input }],
    legend: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    BaseChartDirective.prototype.data;
    /** @type {?} */
    BaseChartDirective.prototype.datasets;
    /** @type {?} */
    BaseChartDirective.prototype.labels;
    /** @type {?} */
    BaseChartDirective.prototype.options;
    /** @type {?} */
    BaseChartDirective.prototype.chartType;
    /** @type {?} */
    BaseChartDirective.prototype.colors;
    /** @type {?} */
    BaseChartDirective.prototype.legend;
    /** @type {?} */
    BaseChartDirective.prototype.chartClick;
    /** @type {?} */
    BaseChartDirective.prototype.chartHover;
    /** @type {?} */
    BaseChartDirective.prototype.ctx;
    /** @type {?} */
    BaseChartDirective.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.initFlag;
    /**
     * @type {?}
     * @private
     */
    BaseChartDirective.prototype.element;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jaGFydC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZzItY2hhcnRzLyIsInNvdXJjZXMiOlsibGliL2Jhc2UtY2hhcnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUlULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsRUFFWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssT0FBTyxNQUFNLFVBQVUsQ0FBQztBQUNwQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7O0FBV3pDLHFEQUVDOzs7SUFEQyw2Q0FBWTs7Ozs7QUFHZCxzREFpREM7Ozs7Ozs7SUFoREMsOEZBQXVEOzs7Ozs7SUFDdkQsNkZBQXNEOzs7Ozs7SUFFdEQsZ0dBQXlEOzs7Ozs7SUFDekQsK0ZBQXdEOzs7Ozs7SUFFeEQsZ0dBQXlEOzs7Ozs7SUFDekQsK0ZBQXdEOzs7Ozs7SUFFeEQsd0dBQWlFOzs7Ozs7SUFDakUsdUdBQWdFOzs7Ozs7SUFFaEUsdUdBQWdFOzs7Ozs7SUFDaEUsc0dBQStEOzs7Ozs7SUFLL0QsZ0dBQXlEOzs7Ozs7SUFDekQsK0ZBQXdEOzs7Ozs7O0lBR3hELHNHQUF1RTs7Ozs7OztJQUN2RSxxR0FBc0U7Ozs7Ozs7SUFHdEUsOEdBQStFOzs7Ozs7O0lBQy9FLDZHQUE4RTs7Ozs7OztJQUU5RSw2R0FBOEU7Ozs7Ozs7SUFDOUUsNEdBQTZFOzs7Ozs7O0lBSTdFLGtIQUFpRjs7Ozs7OztJQUdqRixpSEFBZ0Y7Ozs7Ozs7SUFHaEYsc0dBQXNFOzs7Ozs7O0lBQ3RFLHFHQUFxRTs7Ozs7OztJQUVyRSx3R0FBa0Y7Ozs7O0lBQ2xGLGtGQUFxQzs7Ozs7OztJQUdyQyxvR0FBNkQ7O0FBVS9ELE1BQU0sT0FBTyxrQkFBa0I7Ozs7SUF1QjdCLFlBQTJCLE9BQW1CO1FBQW5CLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFuQjlCLFlBQU8sR0FBeUIs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QUMsS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQSx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7OztZQXhNRixTQUFTLFNBQUM7O2dCQUVULFFBQVEsRUFBRSxtQkFBbUI7Z0JBQzdCLFFBQVEsRUFBRSxZQUFZO2FBQ3ZCOzs7O1lBNUVDLFVBQVU7OzttQkE4RVQsS0FBSzt1QkFDTCxLQUFLO3FCQUNMLEtBQUs7c0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3FCQUNMLEtBQUs7cUJBQ0wsS0FBSzt5QkFFTCxNQUFNO3lCQUNOLE1BQU07Ozs7SUFUUCxrQ0FBMkM7O0lBQzNDLHNDQUFrRDs7SUFDbEQsb0NBQWlDOztJQUNqQyxxQ0FBbUQ7O0lBQ25ELHVDQUE2Qzs7SUFDN0Msb0NBQWdDOztJQUNoQyxvQ0FBZ0M7O0lBRWhDLHdDQUFzRzs7SUFDdEcsd0NBQW9HOztJQUVwRyxpQ0FBbUI7O0lBQ25CLG1DQUFvQjs7Ozs7SUFDcEIsc0NBQXlCOzs7OztJQVNOLHFDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIE9uRGVzdHJveSxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25Jbml0LFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgRWxlbWVudFJlZixcclxuICBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGNoYXJ0SnMgZnJvbSAnY2hhcnQuanMnO1xyXG5pbXBvcnQgeyBnZXRDb2xvcnMgfSBmcm9tICcuL2dldC1jb2xvcnMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4vY29sb3InO1xyXG5cclxuZXhwb3J0IHR5cGUgU2luZ2xlRGF0YVNldCA9IChudW1iZXJbXSB8IGNoYXJ0SnMuQ2hhcnRQb2ludFtdKTtcclxuZXhwb3J0IHR5cGUgTXVsdGlEYXRhU2V0ID0gKG51bWJlcltdIHwgY2hhcnRKcy5DaGFydFBvaW50W10pW107XHJcbmV4cG9ydCB0eXBlIFNpbmdsZU9yTXVsdGlEYXRhU2V0ID0gU2luZ2xlRGF0YVNldCB8IE11bHRpRGF0YVNldDtcclxuXHJcbi8qIFRoZSBmb2xsb3dpbmcgdHdvIHR5cGVzIGFyZSBjb3BpZWQgZnJvbSBAdHlwZXMvY2hhcnQuanMgYmVjYXVzZSB0aGV5IGFyZSBub3RcclxuICogZXhwb3J0ZWQgZnJvbSB0aGVyZS4gVGhlcmUgaXMgYSBwdWxsIHJlcXVlc3QgdG8gZGVmaW5pdGVseSB0eXBlIHJlcXVlc3RpbmcgdGhpc1xyXG4gKiBjaGFuZ2UgKFBSICMzMzYxNCBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9wdWxsLzMzNjE0KVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQbHVnaW5TZXJ2aWNlR2xvYmFsUmVnaXN0cmF0aW9uIHtcclxuICBpZD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQbHVnaW5TZXJ2aWNlUmVnaXN0cmF0aW9uT3B0aW9ucyB7XHJcbiAgYmVmb3JlSW5pdD8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVySW5pdD8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICBiZWZvcmVVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlclVwZGF0ZT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICBiZWZvcmVMYXlvdXQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckxheW91dD8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICBiZWZvcmVEYXRhc2V0c1VwZGF0ZT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVyRGF0YXNldHNVcGRhdGU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuXHJcbiAgYmVmb3JlRGF0YXNldFVwZGF0ZT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVyRGF0YXNldFVwZGF0ZT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICAvLyBUaGlzIGlzIGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgYSByZW5kZXIuIEl0IGlzIG9ubHkgY2FsbGVkIG9uY2UsIGV2ZW4gaWZcclxuICAvLyB0aGUgYW5pbWF0aW9uIHdpbGwgcnVuIGZvciBhIG51bWJlciBvZiBmcmFtZXMuIFVzZSBiZWZvcmVEcmF3IG9yIGFmdGVyRHJhd1xyXG4gIC8vIHRvIGRvIHNvbWV0aGluZyBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZVxyXG4gIGJlZm9yZVJlbmRlcj8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVyUmVuZGVyPyhjaGFydEluc3RhbmNlOiBDaGFydCwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcblxyXG4gIC8vIEVhc2luZyBpcyBmb3IgYW5pbWF0aW9uXHJcbiAgYmVmb3JlRHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIGVhc2luZzogc3RyaW5nLCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckRyYXc/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBlYXNpbmc6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcblxyXG4gIC8vIEJlZm9yZSB0aGUgZGF0YXNldHMgYXJlIGRyYXduIGJ1dCBhZnRlciBzY2FsZXMgYXJlIGRyYXduXHJcbiAgYmVmb3JlRGF0YXNldHNEcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZWFzaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVyRGF0YXNldHNEcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZWFzaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICBiZWZvcmVEYXRhc2V0RHJhdz8oY2hhcnRJbnN0YW5jZTogQ2hhcnQsIGVhc2luZzogc3RyaW5nLCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICBhZnRlckRhdGFzZXREcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgZWFzaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICAvLyBDYWxsZWQgYmVmb3JlIGRyYXdpbmcgdGhlIGB0b29sdGlwYC4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXHJcbiAgLy8gdGhlIHRvb2x0aXAgZHJhd2luZyBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgcmVuZGVyYCBpcyB0cmlnZ2VyZWQuXHJcbiAgYmVmb3JlVG9vbHRpcERyYXc/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCB0b29sdGlwRGF0YT86IGFueSwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgLy8gQ2FsbGVkIGFmdGVyIGRyYXdpbmcgdGhlIGB0b29sdGlwYC4gTm90ZSB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdCxcclxuICAvLyBiZSBjYWxsZWQgaWYgdGhlIHRvb2x0aXAgZHJhd2luZyBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cclxuICBhZnRlclRvb2x0aXBEcmF3PyhjaGFydEluc3RhbmNlOiBDaGFydCwgdG9vbHRpcERhdGE/OiBhbnksIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICAvLyBDYWxsZWQgd2hlbiBhbiBldmVudCBvY2N1cnMgb24gdGhlIGNoYXJ0XHJcbiAgYmVmb3JlRXZlbnQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBldmVudDogRXZlbnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gIGFmdGVyRXZlbnQ/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBldmVudDogRXZlbnQsIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG5cclxuICByZXNpemU/KGNoYXJ0SW5zdGFuY2U6IENoYXJ0LCBuZXdDaGFydFNpemU6IENoYXJ0LkNoYXJ0U2l6ZSwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbiAgZGVzdHJveT8oY2hhcnRJbnN0YW5jZTogQ2hhcnQpOiB2b2lkO1xyXG5cclxuICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMC4gVXNlIGBhZnRlckxheW91dGAgaW5zdGVhZC4gKi9cclxuICBhZnRlclNjYWxlVXBkYXRlPyhjaGFydEluc3RhbmNlOiBDaGFydCwgb3B0aW9ucz86IGFueSk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFBsdWdpblNlcnZpY2VHbG9iYWxSZWdpc3RyYXRpb25BbmRPcHRpb25zID0gUGx1Z2luU2VydmljZUdsb2JhbFJlZ2lzdHJhdGlvbiAmIFBsdWdpblNlcnZpY2VSZWdpc3RyYXRpb25PcHRpb25zO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxyXG4gIHNlbGVjdG9yOiAnY2FudmFzW2Jhc2VDaGFydF0nLFxyXG4gIGV4cG9ydEFzOiAnYmFzZS1jaGFydCdcclxufSlcclxuZXhwb3J0IGNsYXNzIEJhc2VDaGFydERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBPbkluaXQge1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBkYXRhOiBTaW5nbGVPck11bHRpRGF0YVNldDtcclxuICBASW5wdXQoKSBwdWJsaWMgZGF0YXNldHM6IGNoYXJ0SnMuQ2hhcnREYXRhU2V0c1tdO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBsYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBvcHRpb25zOiBjaGFydEpzLkNoYXJ0T3B0aW9ucyA9IHt9O1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBjaGFydFR5cGU6IGNoYXJ0SnMuQ2hhcnRUeXBlO1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBjb2xvcnM6IENvbG9yW107XHJcbiAgQElucHV0KCkgcHVibGljIGxlZ2VuZDogYm9vbGVhbjtcclxuXHJcbiAgQE91dHB1dCgpIHB1YmxpYyBjaGFydENsaWNrOiBFdmVudEVtaXR0ZXI8eyBldmVudD86IE1vdXNlRXZlbnQsIGFjdGl2ZT86IHt9W10gfT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgQE91dHB1dCgpIHB1YmxpYyBjaGFydEhvdmVyOiBFdmVudEVtaXR0ZXI8eyBldmVudDogTW91c2VFdmVudCwgYWN0aXZlOiB7fVtdIH0+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBwdWJsaWMgY3R4OiBzdHJpbmc7XHJcbiAgcHVibGljIGNoYXJ0OiBDaGFydDtcclxuICBwcml2YXRlIGluaXRGbGFnID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luOiBQbHVnaW5TZXJ2aWNlR2xvYmFsUmVnaXN0cmF0aW9uQW5kT3B0aW9ucykge1xyXG4gICAgY2hhcnRKcy5DaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbik7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbiAgcHVibGljIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy5jdHggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgdGhpcy5pbml0RmxhZyA9IHRydWU7XHJcbiAgICBpZiAodGhpcy5kYXRhIHx8IHRoaXMuZGF0YXNldHMpIHtcclxuICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgaWYgKHRoaXMuaW5pdEZsYWcpIHtcclxuICAgICAgbGV0IHVwZGF0ZVJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGFuZ2VzIGFyZSBpbiB0aGUgZGF0YSBvciBkYXRhc2V0cyBvciBsYWJlbHMgb3IgbGVnZW5kXHJcblxyXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpIHx8IGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2RhdGFzZXRzJykpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5kYXRhKSB7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0RGF0YShjaGFuZ2VzLmRhdGEuY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVDaGFydERhdGEoY2hhbmdlcy5kYXRhc2V0cy5jdXJyZW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBkYXRlUmVxdWlyZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdsYWJlbHMnKSkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgPSBjaGFuZ2VzLmxhYmVscy5jdXJyZW50VmFsdWU7XHJcblxyXG4gICAgICAgIHVwZGF0ZVJlcXVpcmVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbGVnZW5kJykpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLmxlZ2VuZC5kaXNwbGF5ID0gY2hhbmdlcy5sZWdlbmQuY3VycmVudFZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZ2VuZXJhdGVMZWdlbmQoKTtcclxuXHJcbiAgICAgICAgdXBkYXRlUmVxdWlyZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodXBkYXRlUmVxdWlyZWQpIHtcclxuICAgICAgICAvLyAuLi4gaWYgc28sIHVwZGF0ZSBjaGFydFxyXG4gICAgICAgIHRoaXMuY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJlYnVpbGQgdGhlIGNoYXJ0XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLmNoYXJ0KSB7XHJcbiAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xyXG4gICAgICB0aGlzLmNoYXJ0ID0gdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHVwZGF0ZShkdXJhdGlvbj86IGFueSwgbGF6eT86IGFueSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hhcnQudXBkYXRlKGR1cmF0aW9uLCBsYXp5KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRDaGFydEJ1aWxkZXIoY3R4OiBzdHJpbmcvKiwgZGF0YTphbnlbXSwgb3B0aW9uczphbnkqLyk6IENoYXJ0IHtcclxuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5nZXREYXRhc2V0cygpO1xyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgaWYgKHRoaXMubGVnZW5kID09PSBmYWxzZSkge1xyXG4gICAgICBvcHRpb25zLmxlZ2VuZCA9IHsgZGlzcGxheTogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIC8vIGhvb2sgZm9yIG9uSG92ZXIgYW5kIG9uQ2xpY2sgZXZlbnRzXHJcbiAgICBvcHRpb25zLmhvdmVyID0gb3B0aW9ucy5ob3ZlciB8fCB7fTtcclxuICAgIGlmICghb3B0aW9ucy5ob3Zlci5vbkhvdmVyKSB7XHJcbiAgICAgIG9wdGlvbnMuaG92ZXIub25Ib3ZlciA9IChldmVudDogTW91c2VFdmVudCwgYWN0aXZlOiB7fVtdKSA9PiB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZSAmJiAhYWN0aXZlLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYXJ0SG92ZXIuZW1pdCh7IGV2ZW50LCBhY3RpdmUgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLm9uQ2xpY2spIHtcclxuICAgICAgb3B0aW9ucy5vbkNsaWNrID0gKGV2ZW50PzogTW91c2VFdmVudCwgYWN0aXZlPzoge31bXSkgPT4ge1xyXG4gICAgICAgIHRoaXMuY2hhcnRDbGljay5lbWl0KHsgZXZlbnQsIGFjdGl2ZSB9KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGFydENvbmZpZzogY2hhcnRKcy5DaGFydENvbmZpZ3VyYXRpb24gPSB7XHJcbiAgICAgIHR5cGU6IHRoaXMuY2hhcnRUeXBlLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiB0aGlzLmxhYmVscyxcclxuICAgICAgICBkYXRhc2V0c1xyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgY2hhcnRKcy5DaGFydChjdHgsIGNoYXJ0Q29uZmlnKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNDaGFydERhdGFTZXRzQXJyYXkodjogU2luZ2xlT3JNdWx0aURhdGFTZXQgfCBjaGFydEpzLkNoYXJ0RGF0YVNldHNbXSk6IHYgaXMgY2hhcnRKcy5DaGFydERhdGFTZXRzW10ge1xyXG4gICAgY29uc3QgZWxtID0gdlswXTtcclxuICAgIHJldHVybiAodHlwZW9mIChlbG0pID09PSAnb2JqZWN0JykgJiYgJ2RhdGEnIGluIGVsbTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlQ2hhcnREYXRhKG5ld0RhdGFWYWx1ZXM6IFNpbmdsZU9yTXVsdGlEYXRhU2V0IHwgY2hhcnRKcy5DaGFydERhdGFTZXRzW10pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlzQ2hhcnREYXRhU2V0c0FycmF5KG5ld0RhdGFWYWx1ZXMpKSB7XHJcbiAgICAgIGlmIChuZXdEYXRhVmFsdWVzLmxlbmd0aCA9PT0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBpOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIGRhdGFzZXQuZGF0YSA9IG5ld0RhdGFWYWx1ZXNbaV0uZGF0YTtcclxuICAgICAgICAgIGlmIChuZXdEYXRhVmFsdWVzW2ldLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIGRhdGFzZXQubGFiZWwgPSBuZXdEYXRhVmFsdWVzW2ldLmxhYmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cyA9IFsuLi5uZXdEYXRhVmFsdWVzXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1NpbmdsZURhdGFTZXQobmV3RGF0YVZhbHVlcykpIHtcclxuICAgICAgaWYgKG5ld0RhdGFWYWx1ZXMubGVuZ3RoID09PSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgZGF0YXNldC5kYXRhID0gbmV3RGF0YVZhbHVlc1tpXTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMgPSBuZXdEYXRhVmFsdWVzLm1hcCgoZGF0YTogbnVtYmVyW10sIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiB7IGRhdGEsIGxhYmVsOiB0aGlzLmxhYmVsc1tpbmRleF0gfHwgYExhYmVsICR7aW5kZXh9YCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YSA9IG5ld0RhdGFWYWx1ZXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzU2luZ2xlRGF0YVNldChkYXRhOiBTaW5nbGVPck11bHRpRGF0YVNldCk6IGRhdGEgaXMgU2luZ2xlRGF0YVNldCB7XHJcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoZGF0YVswXSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldERhdGFzZXRzKCkge1xyXG4gICAgbGV0IGRhdGFzZXRzOiBjaGFydEpzLkNoYXJ0RGF0YVNldHNbXSA9IHZvaWQgMDtcclxuICAgIC8vIGluIGNhc2UgaWYgZGF0YXNldHMgaXMgbm90IHByb3ZpZGVkLCBidXQgZGF0YSBpcyBwcmVzZW50XHJcbiAgICBpZiAoIXRoaXMuZGF0YXNldHMgfHwgIXRoaXMuZGF0YXNldHMubGVuZ3RoICYmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCkpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzU2luZ2xlRGF0YVNldCh0aGlzLmRhdGEpKSB7XHJcbiAgICAgICAgZGF0YXNldHMgPSB0aGlzLmRhdGEubWFwKChkYXRhOiBudW1iZXJbXSwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHsgZGF0YSwgbGFiZWw6IHRoaXMubGFiZWxzW2luZGV4XSB8fCBgTGFiZWwgJHtpbmRleH1gIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YXNldHMgPSBbeyBkYXRhOiB0aGlzLmRhdGEsIGxhYmVsOiBgTGFiZWwgMGAgfV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kYXRhc2V0cyAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCB8fFxyXG4gICAgICAoZGF0YXNldHMgJiYgZGF0YXNldHMubGVuZ3RoKSkge1xyXG4gICAgICBkYXRhc2V0cyA9ICh0aGlzLmRhdGFzZXRzIHx8IGRhdGFzZXRzKVxyXG4gICAgICAgIC5tYXAoKGVsbTogY2hhcnRKcy5DaGFydERhdGFTZXRzLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBuZXdFbG06IGNoYXJ0SnMuQ2hhcnREYXRhU2V0cyA9IE9iamVjdC5hc3NpZ24oe30sIGVsbSk7XHJcbiAgICAgICAgICBpZiAodGhpcy5jb2xvcnMgJiYgdGhpcy5jb2xvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3RWxtLCB0aGlzLmNvbG9yc1tpbmRleF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdFbG0sIGdldENvbG9ycyh0aGlzLmNoYXJ0VHlwZSwgaW5kZXgsIG5ld0VsbS5kYXRhLmxlbmd0aCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG5ld0VsbTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRhdGFzZXRzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmctY2hhcnRzIGNvbmZpZ3VyYXRpb24gZXJyb3IsXHJcbiAgICAgIGRhdGEgb3IgZGF0YXNldHMgZmllbGQgYXJlIHJlcXVpcmVkIHRvIHJlbmRlciBjaGFyICR7dGhpcy5jaGFydFR5cGV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGFzZXRzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWZyZXNoKCkge1xyXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgLy8gICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVmcmVzaCgpLCA1MCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gdG9kbzogcmVtb3ZlIHRoaXMgbGluZSwgaXQgaXMgcHJvZHVjaW5nIGZsaWNrZXJpbmdcclxuICAgIHRoaXMubmdPbkRlc3Ryb3koKTtcclxuICAgIHRoaXMuY2hhcnQgPSB0aGlzLmdldENoYXJ0QnVpbGRlcih0aGlzLmN0eC8qLCBkYXRhLCB0aGlzLm9wdGlvbnMqLyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==
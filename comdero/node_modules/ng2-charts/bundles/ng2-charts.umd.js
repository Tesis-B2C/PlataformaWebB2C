(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('chart.js')) :
    typeof define === 'function' && define.amd ? define('ng2-charts', ['exports', '@angular/core', 'chart.js'], factory) :
    (factory((global['ng2-charts'] = {}),global.ng.core,global.chart_js));
}(this, (function (exports,core,chartJs) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultColors = [
        [255, 99, 132],
        [54, 162, 235],
        [255, 206, 86],
        [231, 233, 237],
        [75, 192, 192],
        [151, 187, 205],
        [220, 220, 220],
        [247, 70, 74],
        [70, 191, 189],
        [253, 180, 92],
        [148, 159, 177],
        [77, 83, 96]
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Generate colors by chart type
     * @param {?} chartType
     * @param {?} index
     * @param {?} count
     * @return {?}
     */
    function getColors(chartType, index, count) {
        if (chartType === 'pie' || chartType === 'doughnut') {
            return formatPieColors(generateColors(count));
        }
        if (chartType === 'polarArea') {
            return formatPolarAreaColors(generateColors(count));
        }
        if (chartType === 'line' || chartType === 'radar') {
            return formatLineColor(generateColor(index));
        }
        if (chartType === 'bar' || chartType === 'horizontalBar') {
            return formatBarColor(generateColor(index));
        }
        throw new Error("getColors - Unsupported chart type " + chartType);
    }
    /**
     * @param {?} colour
     * @param {?} alpha
     * @return {?}
     */
    function rgba(colour, alpha) {
        return 'rgba(' + colour.concat(alpha).join(',') + ')';
    }
    /**
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatLineColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.4),
            borderColor: rgba(colors, 1),
            pointBackgroundColor: rgba(colors, 1),
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: rgba(colors, 0.8)
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatBarColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.6),
            borderColor: rgba(colors, 1),
            hoverBackgroundColor: rgba(colors, 0.8),
            hoverBorderColor: rgba(colors, 1)
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatPieColors(colors) {
        return {
            backgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.6); })),
            borderColor: colors.map(( /**
             * @return {?}
             */function () { return '#fff'; })),
            pointBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            pointBorderColor: colors.map(( /**
             * @return {?}
             */function () { return '#fff'; })),
            pointHoverBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            pointHoverBorderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); }))
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatPolarAreaColors(colors) {
        return {
            backgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.6); })),
            borderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            hoverBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.8); })),
            hoverBorderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); }))
        };
    }
    /**
     * @return {?}
     */
    function getRandomColor() {
        return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
    }
    /**
     * Generate colors for line|bar charts
     * @param {?} index
     * @return {?}
     */
    function generateColor(index) {
        return defaultColors[index] || getRandomColor();
    }
    /**
     * Generate colors for pie|doughnut charts
     * @param {?} count
     * @return {?}
     */
    function generateColors(count) {
        /** @type {?} */
        var colorsArr = new Array(count);
        for (var i = 0; i < count; i++) {
            colorsArr[i] = defaultColors[i] || getRandomColor();
        }
        return colorsArr;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BaseChartDirective = /** @class */ (function () {
        function BaseChartDirective(element) {
            this.element = element;
            this.options = {};
            this.chartClick = new core.EventEmitter();
            this.chartHover = new core.EventEmitter();
            this.initFlag = false;
        }
        /**
         * Register a plugin.
         */
        /**
         * Register a plugin.
         * @param {?} plugin
         * @return {?}
         */
        BaseChartDirective.registerPlugin = /**
         * Register a plugin.
         * @param {?} plugin
         * @return {?}
         */
            function (plugin) {
                chartJs.Chart.plugins.register(plugin);
            };
        /**
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.ctx = this.element.nativeElement.getContext('2d');
                this.initFlag = true;
                if (this.data || this.datasets) {
                    this.refresh();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (this.initFlag) {
                    /** @type {?} */
                    var updateRequired = false;
                    // Check if the changes are in the data or datasets or labels or legend
                    if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                        if (changes.data) {
                            this.updateChartData(changes.data.currentValue);
                        }
                        else {
                            this.updateChartData(changes.datasets.currentValue);
                        }
                        updateRequired = true;
                    }
                    if (changes.hasOwnProperty('labels')) {
                        this.chart.data.labels = changes.labels.currentValue;
                        updateRequired = true;
                    }
                    if (changes.hasOwnProperty('legend')) {
                        this.chart.config.options.legend.display = changes.legend.currentValue;
                        this.chart.generateLegend();
                        updateRequired = true;
                    }
                    if (updateRequired) {
                        // ... if so, update chart
                        this.chart.update();
                    }
                    else {
                        // otherwise rebuild the chart
                        this.refresh();
                    }
                }
            };
        /**
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = void 0;
                }
            };
        /**
         * @param {?=} duration
         * @param {?=} lazy
         * @return {?}
         */
        BaseChartDirective.prototype.update = /**
         * @param {?=} duration
         * @param {?=} lazy
         * @return {?}
         */
            function (duration, lazy) {
                return this.chart.update(duration, lazy);
            };
        /**
         * @param {?} ctx
         * @return {?}
         */
        BaseChartDirective.prototype.getChartBuilder = /**
         * @param {?} ctx
         * @return {?}
         */
            function (ctx /*, data:any[], options:any*/) {
                var _this = this;
                /** @type {?} */
                var datasets = this.getDatasets();
                /** @type {?} */
                var options = Object.assign({}, this.options);
                if (this.legend === false) {
                    options.legend = { display: false };
                }
                // hook for onHover and onClick events
                options.hover = options.hover || {};
                if (!options.hover.onHover) {
                    options.hover.onHover = ( /**
                     * @param {?} event
                     * @param {?} active
                     * @return {?}
                     */function (event, active) {
                        if (active && !active.length) {
                            return;
                        }
                        _this.chartHover.emit({ event: event, active: active });
                    });
                }
                if (!options.onClick) {
                    options.onClick = ( /**
                     * @param {?=} event
                     * @param {?=} active
                     * @return {?}
                     */function (event, active) {
                        _this.chartClick.emit({ event: event, active: active });
                    });
                }
                /** @type {?} */
                var chartConfig = {
                    type: this.chartType,
                    data: {
                        labels: this.labels,
                        datasets: datasets
                    },
                    options: options
                };
                return new chartJs.Chart(ctx, chartConfig);
            };
        /**
         * @private
         * @param {?} v
         * @return {?}
         */
        BaseChartDirective.prototype.isChartDataSetsArray = /**
         * @private
         * @param {?} v
         * @return {?}
         */
            function (v) {
                /** @type {?} */
                var elm = v[0];
                return (typeof (elm) === 'object') && 'data' in elm;
            };
        /**
         * @private
         * @param {?} newDataValues
         * @return {?}
         */
        BaseChartDirective.prototype.updateChartData = /**
         * @private
         * @param {?} newDataValues
         * @return {?}
         */
            function (newDataValues) {
                var _this = this;
                if (this.isChartDataSetsArray(newDataValues)) {
                    if (newDataValues.length === this.chart.data.datasets.length) {
                        this.chart.data.datasets.forEach(( /**
                         * @param {?} dataset
                         * @param {?} i
                         * @return {?}
                         */function (dataset, i) {
                            dataset.data = newDataValues[i].data;
                            if (newDataValues[i].label) {
                                dataset.label = newDataValues[i].label;
                            }
                        }));
                    }
                    else {
                        this.chart.data.datasets = __spread(newDataValues);
                    }
                }
                else if (!this.isSingleDataSet(newDataValues)) {
                    if (newDataValues.length === this.chart.data.datasets.length) {
                        this.chart.data.datasets.forEach(( /**
                         * @param {?} dataset
                         * @param {?} i
                         * @return {?}
                         */function (dataset, i) {
                            dataset.data = newDataValues[i];
                        }));
                    }
                    else {
                        this.chart.data.datasets = newDataValues.map(( /**
                         * @param {?} data
                         * @param {?} index
                         * @return {?}
                         */function (data, index) {
                            return { data: data, label: _this.labels[index] || "Label " + index };
                        }));
                    }
                }
                else {
                    this.chart.data.datasets[0].data = newDataValues;
                }
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        BaseChartDirective.prototype.isSingleDataSet = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return !Array.isArray(data[0]);
            };
        /**
         * @private
         * @return {?}
         */
        BaseChartDirective.prototype.getDatasets = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var datasets = void 0;
                // in case if datasets is not provided, but data is present
                if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
                    if (!this.isSingleDataSet(this.data)) {
                        datasets = this.data.map(( /**
                         * @param {?} data
                         * @param {?} index
                         * @return {?}
                         */function (data, index) {
                            return { data: data, label: _this.labels[index] || "Label " + index };
                        }));
                    }
                    else {
                        datasets = [{ data: this.data, label: "Label 0" }];
                    }
                }
                if (this.datasets && this.datasets.length ||
                    (datasets && datasets.length)) {
                    datasets = (this.datasets || datasets)
                        .map(( /**
                 * @param {?} elm
                 * @param {?} index
                 * @return {?}
                 */function (elm, index) {
                        /** @type {?} */
                        var newElm = Object.assign({}, elm);
                        if (_this.colors && _this.colors.length) {
                            Object.assign(newElm, _this.colors[index]);
                        }
                        else {
                            Object.assign(newElm, getColors(_this.chartType, index, newElm.data.length));
                        }
                        return newElm;
                    }));
                }
                if (!datasets) {
                    throw new Error("ng-charts configuration error,\n      data or datasets field are required to render char " + this.chartType);
                }
                return datasets;
            };
        /**
         * @private
         * @return {?}
         */
        BaseChartDirective.prototype.refresh = /**
         * @private
         * @return {?}
         */
            function () {
                // if (this.options && this.options.responsive) {
                //   setTimeout(() => this.refresh(), 50);
                // }
                // todo: remove this line, it is producing flickering
                this.ngOnDestroy();
                this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
            };
        BaseChartDirective.decorators = [
            { type: core.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'canvas[baseChart]',
                        exportAs: 'base-chart'
                    },] }
        ];
        /** @nocollapse */
        BaseChartDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        BaseChartDirective.propDecorators = {
            data: [{ type: core.Input }],
            datasets: [{ type: core.Input }],
            labels: [{ type: core.Input }],
            options: [{ type: core.Input }],
            chartType: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            legend: [{ type: core.Input }],
            chartClick: [{ type: core.Output }],
            chartHover: [{ type: core.Output }]
        };
        return BaseChartDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ChartsModule = /** @class */ (function () {
        function ChartsModule() {
        }
        ChartsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BaseChartDirective
                        ],
                        imports: [],
                        exports: [
                            BaseChartDirective
                        ]
                    },] }
        ];
        return ChartsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.ChartsModule = ChartsModule;
    exports.BaseChartDirective = BaseChartDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ng2-charts.umd.js.map